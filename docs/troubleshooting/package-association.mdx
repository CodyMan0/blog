---
title: 의존성 제대로 모르면 재앙이 일어난다...
sidebar_position: 1
last_update:
  date: 08/13/2025
description: 그냥 넘어가면 안될 실수를 복기해보자
tags: [문제해결]
draft: true
---

## 들어가기 앞서

> 이전 회사에서는 혼자 개발해왔기에 패키지 관련한 문제를 마주해본적이 없었다.
> 다행히 영향 범위가 넓지 않았고 아주 사소한 부분에서 동료 개발자와 의존성 충돌 문제가 있었다.
> 이를 빠르게 알게 돼 즉시 수정할 수 있었다. 이를 돌아보고 개념을 정확히 이해해보려고 한다.

먼저 맥락에 대해 공유하고자 한다.

오픈 닥터 개발팀은 git flow 브랜치 전략을 사용하고 있고
당시 develop 브랜치에서 feat 브랜치를 만들고 feat 브랜치 내부에서 작업을 진행하고 있었다.
그때 스토리북 도입 이야기가 나왔고 개인적으로 스토리북 의존성을 설치한 후 테스트를 진행해보았다.
당장 쉽게 적용하기엔 에러가 발생해서 스토리북과 관련된 모든 커밋을 revert했다.
즉 package.json과 package.lock.json 내부에 스토리북과 관련된 파일은 모두 없앴다.

> 모든 커밋을 되돌렸기에 이게 무슨 문제를 발생시킬 수 있는지에 대해서 몰랐다.

잠시 후 특정 기능을 테스트 서버에 배포했는데 내가 개발한 기능이 동작하지 않는 것이다. 확인해보니 배포가 실패했다! 이럴 일이 없는데?

![img alt="web-driver"](/img/troubleshooting/package-error1.png)

위의 이미지를 보면 stories.tsx 파일이 있는 것을 볼 수 있다.
그냥 간단히 생각해보면 스토리북 의존성을 제거했는데 파일이 있으니깐 에러가 뜨지! 라고 생각했다.

하지만 한 단계 더 들어가면 이런 문제를 제기할 수 있다. 우리는 husky를 통해 push하면서 소스 코드를 빌드하는 과정이 있다.

그런데? 빌드하면서 왜 에러가 검증이 안된거지? 싶었다.

그래서 동료에게 이 사실을 바로 공유하고 동료의 개발환경에서 빌드를 돌려보니 에러를 뱉는것이었다.

그렇다면 뭐가 문제일까?

난 분명 package.json 내부에 있는 모듈을 삭제했는데?
husky의 설정이 잘못 되어있는지 파악해보았지만 문제는 없었다.

내 로컬 노드 모듈에 storybook의 의존성이 남아있었다.
이를 "npm run ci" 라는 명령어로 해결했는데 이런 실수를 반복하지 않기 위해서 몇 가지를 공부하고자 한다.

우선

0. 패키지 매니저에 대해 학습

1. Node.js와 npm에 대해 학습

- Node.js의 런타임 구조 (Node vs 브라우저 JS 실행 환경 차이)
- npm과 node_modules가 어떻게 동작하는지
- package.json / package-lock.json 역할 차이
  → 왜 둘 다 필요하고, 버전 고정/재현성을 어떻게 보장하는지

2. npm 설치 명령어 동작 차이

- npm install vs npm ci vs npm prune
  → 각각이 node_modules에 어떻게 영향을 주는지
- 잔존 의존성 문제(이번 사례처럼 revert 후 남아있는 패키지)

## 본론

### 패키지 매니저가 동작하는 방식

패키지가 동작하는 방식을 알아보면 세가지 스텝으로 진행된다.

1. Resolution
2. Fetching
3. Linking
   각 스텝에 대해 알아보자.

**Resolution**

Resolution은 package.json에 기록된 의존성 정보를 읽고 해당하는 버전 범위를 체크하는 과정이다.

가령 package.json에 react 패키지가 ^18.0.0 버전으로 기록되어 있다면,
Resolution 과정에서는 react 패키지의 버전이 18.0.0 이상이면서 최대한 최신 버전인 18.99.99 버전을 이용할 수 있구나하고 사용가능한 버전을 체크하는 과정이다.
이때 의존성의 의존성의... 버전도 체크하는 과정을 거쳐서
각 의존성들의 버전을 고정시켜서 최종적으로 사용할 수 있는 버전을 찾는 과정이다.

**Fetching**
Fetching은 체크된 버전의 패키지를 다운받는 과정으로
로컬 캐시가 있는지 확인하고 없다면 원격 저장소에서 패키지를 다운받는 과정이다.

**Linking**
Linking은 다운받은 패키지를 프로젝트에 연결하는 과정으로 패키지를 사용할 수 있도록 프로젝트에 연결하는 과정이다.
npm과 yarn은 node_modules 폴더에 패키지를 설치하고 각 매니저별로 최적화된 방식으로 패키지를 연결한다.

### 패키지 매니저 버져닝

버져닝은 대개 MAJOR.MINOR.PATCH 세 자리로 구성된다. 이보다는 범위를 지정하는 것들을 정리해보려고 한다.

1. `^`

- Major 버전이 동일하면 Minor / Patch 업데이트를 허용한다.

예시를 살펴보자

```package.json
{
  react : ^18.0.0 // -> >= 18.0.0 < 19.0.0 사이 업데이트 허용한다는 의미이다.
}
```

2. `~`

- Minor 버전이 동일하다면 Patch 업데이트 허용

```package.json
{
  react : ^18.0.0 // -> >= 18.0.0 < 19.0.0 사이 업데이트 허용한다는 의미이다.
}
```

### Node.js의 런타임 구조

우선 런타임의 정의를 이해해보자.

"Runtime은 프로그램이 실행되는 동안 제공되는 환경"이라고 한다.

즉 텍스트인 프로그래밍 언어가 실제로 돌아가도록 하는 환경을 말한다.

런타임이 뭐예요? 라고 하면 프로그래밍 언어가 실행될 때 필요한 환경을 제공해주는 것을 런타임이라고 할 수 있다.

예를 들면 js라고 하면 브라우저의 API setTimeout 및 여러 DOM API를 말할 수 있지 않을까 싶다.

**[브라우저의 런타임]**

- V8 같은 js 엔진 + 브라우저 API

**[Node.js 런타임]**

- V8 같은 js 엔진 + Node API ( libuv, C++로 작성된 비동기 I/O 엔진)
- 파일 시스템 / 네트워킹 / OS 프로세스 제어 등 제공

간단히 Node.js를 도식화해보면 아래와 같이 할 수 있다.

```mdx
[JS 코드]
↓
[V8 엔진] → JS 해석 및 실행
↓
[Node API + libuv] → 비동기 I/O, 이벤트 루프, OS 기능
↓
[운영체제] → 파일, 네트워크, 스레드
```

### 1-2. Node vs 브라우저 JS 이벤트 루프 차이

잠시 조금 곁가지에 궁금해졌다. node.js와 브라우저 런타임 사이 비동기 처리 방식이 조금 다르다는 것은 알고 있었고 libuv를 사용하고 있다는 것을 알고 있었는데 그 이상 아는게 없다.

이 부분을 학습하면서 양이 길어지다보니, 해당 블로그에서 떼어 다른 포스트로 작성하려고 한다.

### 1-3. npm과 node_modules 정리해보자

Npm은 Node Package Manager의 약자로 Node.js 생태계에서 패키지 설치 관리 도구이다.
package.json은 프로젝트의 의존성 목록과 메타 데이터를 정의하는 파일이다.
package-lock.json은 의존성 트리를 고정하는 파일이라고 하는데, 정확한 패키지 버젼을 기록해놓는 파일이다.
node_modules는 npm install할 때 package-lock.json을 보고 필요한 버전을 가져와 담겨진 폴더일 뿐이다.

### 2-1. 설치 명령어의 차이

1. `npm install`

- package.json 확인 후 패키지 설치
- 기존 node_modules는 그대로 두고, 필요한 패키지만 추가/업데이트한다. 그로 인해 패키지 버젼에 문제가 발생할 수 있음.

npm install할 경우

- package.json 확인 → 필요한 패키지 목록 수집
- npm registry(패키지 저장소)에서 다운로드
- node_modules/에 설치
- package-lock.json 갱신

2. `npm ci`

- 기존 node_modules 통째로 삭제
- package-lock.json 기준으로 정확히 설치
- CI,CD 배포 환경에서 표준적으로 쓰는 방식

### 인사이트

- Node.js와 JavaScript는 다르다

- 런타임/언어/버전의 관계 이해 필요

- 의존성 제거 → npm ci 필요성 이해

협업 측면 교훈

팀원 간 버전 차이를 줄이는 환경 세팅 중요

실행 환경 문서화의 필요성

## 마치며

“버전 차이는 사소해 보이지만, 협업 효율성과 안정성에 직결된다”
다음 회고 목표나 다짐 한 줄

“의존성 되돌림(코드) ≠ 로컬 설치 상태 초기화(환경)” 입니다. 되돌린 뒤엔 npm ci로 로컬도 반드시 “락파일 기준의 깨끗한 상태”로 맞추는 습관을 들이면, 이번 같은 “로컬만 통과/서버는 실패” 이슈가 크게 줄어듭니다.

## 참고

1. https://mygumi.tistory.com/409

## 호기심

1. 왜 package.json은 version range를 사용하고 package-lock.json은 정확히 명시된 버전을 사용하는거지?
