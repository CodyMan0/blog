---
title: 보안 취약점 사례로 이해하는 hasOwnProperty
sidebar_position: 1
last_update:
  date: 01/01/2026
description: 실질적인 사례를 통해 알아보는 javascript
tags: [스터디, js]
draft: true
---

.

📚 References
React v19.2.3 Release Notes: https://github.com/facebook/react/releases/tag/v19.2.3
React v19.2.2 Release Notes: https://github.com/facebook/react/releases/tag/v19.2.2
React v19.2.1 Release Notes: https://github.com/facebook/react/blob/HEAD/CHANGELOG.md#1921-Dec-3-2025

## 들어가며

2025년 12월, 리액트 생태계를 뒤흔든 심각한 보안 취약점이 발견됐다.
이 사건은 단순한 버그가 아닌 **critical security vulnerability**로 분류되었고,
수많은 애플리케이션의 보안이 위협받을 수 있는 상황이었다.

이 보안 패치의 핵심에는 한 줄의 코드가 있었습니다.
바로 `hasOwnProperty.call()`을 활용한 수정이었는데
이 글에서는 이 코드 한 줄을 통해 JavaScript의 중요한 개념들을 함께 살펴보고,
왜 이 작은 변경이 보안상 매우 중요한 의미를 갖는지 알아보려고 한다.

![img alt="security-patch"](/img/study/security-react.png)

## JavaScript 프로토타입과 보안

### 1. JavaScript 프로토타입 상속의 기본

JavaScript의 모든 객체는 '프로토타입(Prototype)'이라는 조상 객체로부터 속성을 상속받습니다. 이는 JavaScript의 핵심 특징 중 하나이지만, 때로는 예상치 못한 동작을 만들어낼 수 있습니다.

예를 들어, 어떤 객체에 직접 정의하지 않은 속성에 접근하려고 하면 JavaScript 엔진은 프로토타입 체인을 따라가며 해당 속성을 찾습니다. 이는 편리한 기능이지만, 동시에 보안 취약점으로 작용할 수 있습니다.

### 2. hasOwnProperty란 무엇인가?

`hasOwnProperty`는 객체가 특정 속성을 **직접 소유**하고 있는지 확인하는 메서드입니다. 상속받은 속성이 아니라, 해당 객체에 실제로 정의된 속성인 경우에만 `true`를 반환합니다.

**기존 방식의 문제점:**

```javascript
// 위험한 코드
const value = moduleExports[metadata[NAME]];
```

이렇게 직접 접근하면 객체가 직접 소유하지 않은 속성도 프로토타입 체인을 통해 접근할 수 있습니다.

**안전한 방식:**

```javascript
// 안전한 코드
if (hasOwnProperty.call(moduleExports, metadata[NAME])) {
  const value = moduleExports[metadata[NAME]];
}
```

### 3. 프로토타입 오염(Prototype Pollution) 공격

#### 위험한 시나리오

만약 공격자가 `metadata[NAME]` 값에 `__proto__`, `constructor`, `toString` 같은 JavaScript의 기본 내장 속성 이름을 넣어서 보낸다면 어떻게 될까요?

**기존 방식의 문제:**

- 이전 코드에서는 모듈이 의도적으로 내보낸 기능이 아님에도 불구하고
- JavaScript 엔진이 상속 구조를 따라가서 해당 내부 속성이나 함수를 반환해 버립니다
- 이는 공격자가 서버 내부의 예기치 않은 함수를 실행하거나 설정을 변경할 수 있는 빌미를 제공합니다

**수정된 방식의 방어:**

- `hasOwnProperty`를 사용하면 `__proto__` 같은 상속된 속성들은 "직접 소유한 속성"이 아니므로 `false`를 반환
- 공격자가 조작된 이름을 보내더라도 서버는 안전하게 `undefined`를 반환하고 공격을 무력화

### 4. 왜 `.call()`을 사용해야 할까?

코드에서 `moduleExports.hasOwnProperty(...)`라고 쓰지 않고 `hasOwnProperty.call(moduleExports, ...)`라고 복잡하게 쓴 이유도 보안과 관련이 있습니다.

**이유:**

- `moduleExports` 자체가 `null`을 프로토타입으로 생성되었을 경우 (`Object.create(null)`)
- 공격자가 `hasOwnProperty`라는 이름의 가짜 속성을 객체에 심어두었을 경우를 대비

외부에서 안전한 `hasOwnProperty` 함수를 가져와서 대상 객체를 검사하는 방식을 택함으로써 검사 과정 자체의 변조 가능성까지 차단한 것입니다.

---

## 보안은 작은 디테일에서 시작된다.

이 한 줄의 코드 변경은 **해당 모듈이 공식적으로 내보낸 데이터만 전달하고,
그 외에 JavaScript 언어 구조를 악용한 비정상적인 접근은 원천 봉쇄하겠다**는 선언입니다.
이를 통해 서버와 클라이언트 간의 데이터 해석 방식을 동기화하고, 잠재적인 보안 구멍을 메웠습니다.

### 배운 점

1. **프로토타입 상속의 이면**: JavaScript의 강력한 기능이 때로는 보안 취약점이 될 수 있음을 알 수 있었습니다.
2. **hasOwnProperty의 중요성**: 객체의 속성에 접근할 때는 직접 소유한 속성인지 확인하는 습관이 필요합니다.
3. **방어적 프로그래밍**: `.call()`을 사용하는 것처럼, 보안은 단순히 기능을 구현하는 것 이상의 사고가 필요합니다.

이번 사건을 통해 JavaScript의 기본 개념들을 다시 한 번 되돌아볼 수 있었고, 보안이 단순히 별도의 기능이 아니라 코드 작성 방식 자체에 녹아있어야 한다는 것을 깨달았습니다.
